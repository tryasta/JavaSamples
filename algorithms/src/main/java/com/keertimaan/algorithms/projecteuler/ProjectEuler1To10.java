/**
 * Copyright 2015 Sayem Ahmed
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.keertimaan.algorithms.projecteuler;

import java.math.BigInteger;

/**
 * @author <a href="http://www.codesod.com">Sayem Ahmed</a>
 */
public class ProjectEuler1To10 {

  /**
   * <h1>Description</h1>
   * <p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of
   * these multiples is 23. Find the sum of all the multiples of 3 or 5 below a certain limit.</p>
   *
   * <h1>Problem Note</h1>
   * <p><a href="https://projecteuler.net/problem=1">Problem 1.</a></p>
   * <p>Revision 1.</p>
   *
   * @param limit the limit.
   * @return sum of all the multiples of both 3 and 5 which are less than the limit.
   */
  public static int multipleOf3And5LessThan(int limit) {
    limit--;
    return getSumFor(3, limit) + getSumFor(5, limit) - getSumFor(15, limit);
  }

  /**
   * <h1>Description</h1>
   * <p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and
   * 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89. By considering the terms in the Fibonacci
   * sequence whose values do not exceed a certain limit, find the sum of the even-valued terms.</p>
   *
   * <h1>Golden Ratio</h1>
   * <p>The Golden Ratio is the ratio of the two consecutive elements in the Fibonacci Sequence. It's represented by
   * the symbol φ, and the approximate value of this is 1.61803398875. Hence, the ratio between consecutive even
   * numbers in this sequence becomes φ^3. A good and effcient strategy then would be to start with the lowest even
   * number, and keep multiplying it with φ^3 to get the next even number in the sequence, but this approach will
   * not give accurate result due to rounding issues.</p>
   *
   * <p>Using this ratio, we can even calculate any Fibonacci Number with the help of the following formula -</p>
   *
   * <pre>
   *   F(n) = (Φ^n - (1 - Φ)^n) ∕ √5
   * </pre>
   *
   * <h1>Using the Even Number Occurrence Pattern</h1>
   * <p>From the Fibonacci Sequence, we can see that every 3rd number in the sequence is an even number (if we start
   * from 1, 1). So, if x = 1 and y = 1, then the next even number is x + y, and the next two odd terms after that is
   * x + 2y and 2x + 3y, respectively. Using this technique we can improve the calculation even further by reducing
   * the total number of looping.</p>
   *
   * <h1>Problem Note</h1>
   * <p><a href="https://projecteuler.net/problem=2">Problem 2.</a></p>
   * <p>Revision 2.</p>
   *
   * @param limit the limit
   * @return the sum of all the even-valued Fibonacci terms which do not exceed the limit
   */
  public static long fibonacciEvenSum(int limit) {
    int secondLastFibonacci = 1;
    int lastFibonacci = 1;
    int currentFibonacci = 2;
    long sum = 0;

    while (currentFibonacci <= limit) {
      sum += currentFibonacci;
      currentFibonacci = lastFibonacci;
      lastFibonacci = (secondLastFibonacci << 1) + (lastFibonacci * 3);
      secondLastFibonacci = secondLastFibonacci + (currentFibonacci << 1);
      currentFibonacci = secondLastFibonacci + lastFibonacci;
    }

    return sum;
  }

  /**
   * <h1>Description</h1>
   * <p>The prime factors of 13195 are 5, 7, 13 and 29. Calculate the largest prime factor of a given number.</p>
   *
   * <h1>Problem Note</h1>
   * <p><a href="https://projecteuler.net/problem=3">Problem 3.</a></p>
   * <p>Revision 1.</p>
   *
   * @param number the input number
   * @return the largest prime factor of the input number
   */
  public static BigInteger largestPrimeFactor(BigInteger number) {
    BigInteger divisor = BigInteger.valueOf(2);
    while (number.compareTo(BigInteger.ONE) > 0) {
      BigInteger[] result = number.divideAndRemainder(divisor);
      if ((result[1].longValue() == 0)) {
        number = result[0];
      } else {
        divisor = divisor.add(BigInteger.valueOf(1));
      }
    }

    return divisor;
  }

  private static int getSumFor(int num, int limit) {
    int lastTerm = limit / num;
    return num * ((lastTerm * (lastTerm + 1)) / 2);
  }
}
